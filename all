{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [

    {
      "type": "wpilib",
      "name": "WPILib Desktop Debug",
      "request": "launch",
      "desktop": true,
    },
    {
      "type": "wpilib",
      "name": "WPILib roboRIO Debug",
      "request": "launch",
      "desktop": false,
    }
  ]
}

{
  "java.configuration.updateBuildConfiguration": "automatic",
  "java.server.launchMode": "Standard",
  "files.exclude": {
    "**/.git": true,
    "**/.svn": true,
    "**/.hg": true,
    "**/CVS": true,
    "**/.DS_Store": true,
    "bin/": true,
    "**/.classpath": true,
    "**/.project": true,
    "**/.settings": true,
    "**/.factorypath": true,
    "**/*~": true
  },
  "java.test.config": [
    {
      "name": "WPIlibUnitTests",
      "workingDirectory": "${workspaceFolder}/build/jni/release",
      "vmargs": [ "-Djava.library.path=${workspaceFolder}/build/jni/release" ],
      "env": {
        "LD_LIBRARY_PATH": "${workspaceFolder}/build/jni/release" ,
        "DYLD_LIBRARY_PATH": "${workspaceFolder}/build/jni/release"
      }
    },
  ],
  "java.test.defaultConfig": "WPIlibUnitTests"
}
{
    "enableCppIntellisense": false,
    "currentLanguage": "java",
    "projectYear": "2024",
    "teamNumber": 1086
}
distributionBase=GRADLE_USER_HOME
distributionPath=permwrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.5-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=permwrapper/dists
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

public final class Constants {
    public class DriveConstants {
        // Motor IDs
        public static final int FrontLeftID = 1;
        public static final int FrontRightID = 2;
        public static final int BackLeftID = 3;
        public static final int BackRightID = 4;

        // Other constants
        public static final double deadband = 0.02;
        public static final double minDriveSpeed = 0.6;
        public static final double minTurnSpeed = 0.6;
        public static final boolean squareInputs = true;
    }

    public class IntakeConstants {
        // Motor/Solenoid IDs
        public static final int FrontRollerID = 11;
        public static final int LeftIndexerID = 12;
        public static final int RightIndexerID = 13;
        public static final int BottomTrackID = 14;
        public static final int SolenoidID = 8;
        
        // min Speeds
        public static final double minIntakeSpeed = 0.4;
    }
    
    public class TowerConstants {
        // Motor/Solenoid IDs
        public static final int LeftLaunchRollerID = 21;
        public static final int RightLaunchRollerID = 22;
        public static final int FeedRollerID = 23;
        public static final int SolenoidID = 9;

        // min Speeds
        public static final double minLaunchSpeed = 0.6;
        public static final double minFeedSpeed = 1;
    }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import edu.wpi.first.wpilibj.RobotBase;

/**
 * Do NOT add any static variables to this class, or any initialization at all. Unless you know what
 * you are doing, do not modify this file except to change the parameter class to the startRobot
 * call.
 */
public final class Main {
    private Main() {}

    /**
     * Main initialization function. Do not perform any initialization here.
     *
     * <p>If you change your main robot class, change the parameter type.
     */
    public static void main(String... args) {
        RobotBase.startRobot(Robot::new);
    }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.CommandScheduler;

/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to
 * each mode, as described in the TimedRobot documentation. If you change the name of this class or
 * the package after creating this project, you must also update the build.gradle file in the
 * project.
 * 
 * This class may look different than the auto-generated one because I looked into some of the
 * TimedRobot functions, and found a better way to schedule commands.
 */
public class Robot extends TimedRobot {
    // Decares the various commands to be used later.
    private Command autonomousCommand;
    private Command teleopCommand;

    /** This command runs once when the robot has just been enabled. */
    @Override
    public void robotInit() {
        // Instantiate our RobotContainer.  This will perform all our button bindings, and put our autonomous chooser on the dashboard.
        RobotContainer robotContainer = new RobotContainer();
        
        // Gets the commands for each specific mode from the RobotContainer class.
        this.autonomousCommand = robotContainer.getAutonomousCommand();
        this.teleopCommand = robotContainer.getTeleopCommand();
    }

    /**
     * This function is called every 20 ms, no matter the mode.
     * This duty cycle can be changed by adding a constructor to this class.
     */
    @Override
    public void robotPeriodic() {
        // Runs the Scheduler.
        CommandScheduler.getInstance().run();
    }

    /** This command runs once when the robot enters Autonomous mode. */
    @Override
    public void autonomousInit() {
        autonomousCommand.schedule();
    }

    /** This function is once when the robot exits Autonomous mode. */
    // This command is not used in the auto-generated file.
    @Override
    public void autonomousExit() {
        autonomousCommand.cancel();
    }

    /** This command runs once when the robot enters Teleop mode. */
    @Override
    public void teleopInit() {
        teleopCommand.schedule();
    }

    /** This function is once when the robot exits Teleop mode. */
    @Override
    public void teleopExit() {
        teleopCommand.cancel();
    }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
import edu.wpi.first.wpilibj.PneumaticHub;
import edu.wpi.first.wpilibj2.command.Command;

import frc.robot.subsystems.Drivetrain.Drivetrain;
import frc.robot.subsystems.Drivetrain.Commands.*;
import frc.robot.subsystems.Intake.Intake;
import frc.robot.subsystems.Intake.Commands.*;
import frc.robot.subsystems.Tower.Tower;
import frc.robot.subsystems.Tower.Commands.*;

/**
 * This class is where the bulk of the robot should be declared. Since Command-based is a
 * "declarative" paradigm, very little robot logic should actually be handled in the {@link Robot}
 * periodic methods (other than the scheduler calls). Instead, the structure of the robot (including
 * subsystems, commands, and trigger mappings) should be declared here.
 */
public class RobotContainer {
    // Creates the pneumatics hub
    private final PneumaticHub hub  = new PneumaticHub(31);

    // Initializes the subsystems
    private final Drivetrain drivetrain = new Drivetrain();
    private final Intake intake = new Intake(hub);
    private final Tower tower = new Tower(hub);

    // Creates the remote that controls the robot.
    // Found a new type of XboxController class that makes it a lot easier to make triggers!
    // It even has all of the functionality from the plain XboxController class!
    private final CommandXboxController xbox = new CommandXboxController(0);

    /** The container for the robot. Contains subsystems, IO devices, and commands. */
    public RobotContainer() {
        // Configures the trigger -> command bindings
        configureBindings();
    }

    /** Use this method to define your trigger->command mappings. */
    private void configureBindings() {
        /*
         * A - Runs the feed.
         * B - Opens/closes the intake.
         * X - Runs the intake.
         * Y - Toggles the flywheels.
         * POV Up - Toggles shooter hood.
         * Left Bumper - Run intake/shooter in reverse.
         */
        xbox.a().whileTrue(new RunFeed(tower, 1)); // A
        xbox.b().toggleOnTrue(new SetIntakeState(intake, true)); // B
        xbox.x().whileTrue(new RunIntake(intake, 1)); // X
        xbox.y().toggleOnTrue(new RunLaunch(tower, 1)); // Y
        xbox.povUp().onTrue(new ToggleHoodState(tower)); // POV Up

        // The exception to this method is the left bumper, as it runs all of the subsystems in reverse, and opens all of the solenoids.
        xbox.leftBumper().whileTrue(new SetIntakeState(intake, true)); // Left Bumper
        xbox.leftBumper().whileTrue(new RunIntake(intake, -1)); // Left Bumper
        xbox.leftBumper().whileTrue(new RunFeed(tower, -1)); // Left Bumper
        xbox.leftBumper().whileTrue(new RunLaunch(tower, -1)); // Left Bumper
    }

    /** Passes the autonomous command to the {@link Robot} class. */
    public Command getAutonomousCommand() {
        return new Autonomous(drivetrain, intake, tower);
    }

    /** Passes the teleop command to the {@link Robot} class. */
    public Command getTeleopCommand() {
        return new ArcadeDrive(drivetrain, () -> -xbox.getRawAxis(1), () -> xbox.getRawAxis(4));
    }
}
